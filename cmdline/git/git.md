**START**

# Перед началом работы на проекте

**Поддерживайте ваш репозиторий обновлённым.**

*Не коммитьте ничего в `master` вашего репозитория*

Это помешает вам аккуратно обновлять ваш репозиторий, могут возникнуть конфликты.

*Прежде чем приступать к новому заданию, обновите `master`*

Обновить свой репозиторий из репозитория можно так:


В вашей локальной копии переключитесь в ветку master
```
git checkout master
```

Заберите изменения из репозитория:
```
git pull название_ссылки master
```

**Отправьте изменения в ваш форк на Гитхабе**
```
git push
```

В `название_ссылки` должна быть ссылка на репозиторий. Если его там нет, добавьте:
```
git remote add название_ссылки SSH_репозитория
```

Когда вы обновили `master`, создайте ветку для нового задания:
```
git checkout -b название_ветки
```

---

# Основные команды для работы с Git через консоль

Для начала немного настроек (укажем имя и почту):
```
git config --global user.name your-name
```
```
git config --global user.email your-email
```

-------------------------------------------
Посмотреть сохранённые настройки:
```
git config --list
```

Выводит содержимое файла. Где `~/.gitconfig` - имя нужного файла:
```
cat ~/.gitconfig 
```
-------------------------------------------
Показать состояние репозитория:
```
git status
```

Создать репозиторий:
```
git init
```
-------------------------------------------

## Индексация изменений

Проиндексировать изменения файла:
```
git add имя_файла
```

Проиндексировать все изменения:
```
git add .
```

Показать изменения непроиндексированного файла:
```
git diff имя_файла
```

Если файл уже был проиндексирован, добавим +
```
--staged
```
-------------------------------------------

### Изменили файл, но изменения не понравились, как вернуть все обратно?

Отменить изменения до состояния текущего коммита:
```
git checkout имя_файла
```
-------------------------------------------

### Что делать, если случайно проиндексировали лишний файл?

Отменить индексацию файла:
```
git reset HEAD имя_файла
```
-------------------------------------------

## Коммиты

Собственно сам коммит:
```
git commit -m "сообщение"
```

Показать историю коммитов (здесь берем `hash`) до текущего (`q` - выйти из лога):
```
git log
```

Все коммиты:
```
--all
```

Более удобный вывод (без автора и даты):
```
--oneline
```

Вывод схемой (удобно для веток):
```
--graph
```

Показать изменения в hash-коммите:
```
git show хеш_коммита
```
-------------------------------------------

### Что делать, если случайно закоммитили лишний файл?

Удалить файл из последнего коммита:
```
git rm --cached style.css
```

Изменить коммит:
```
git commit --amend --no-edit
```
-------------------------------------------

### А если допустили ошибку в commit-message?

Изменить комментарий последнего коммита:
```
git commit --amend -m "сообщение"
```
-------------------------------------------

### Как вернуть состояние файла, как во-о-н в том коммите?

Откатить состояние файла до hash-коммита.
Уберем `имя_файла`, если хотим откатить весь репозиторий:
```
git checkout хеш_коммита имя_файла
```
-------------------------------------------

## Ветки

Создать ветку из текущего коммита:
```
git checkout -b имя_ветки
```

Показать список веток:
```
git branch
```
-------------------------------------------

### Эта ветка больше не нужна, как быть?

Удалить ветку (нужно находиться в другой ветке):
```
git branch -d имя_ветки
```
-------------------------------------------

### Что делать, если ошиблись в названии ветки?

Переименовать текущую ветку:
```
git branch -m name
```
-------------------------------------------

### Как создать ветку не из текущего коммита, а вон из того?

Вчера начали изменения в дизайне, но вот появился еще один вариант, создать коммит из текущего не получится, ведь здесь уже внесены изменения...

Создать ветку из коммита, где изменений еще не было:
```
git checkout -b имя_ветки хеш_коммита
```
-------------------------------------------

### Что делать, если сделали изменения не в той ветке, но еще не закоммитили?

Загрузить изменения в стек-грузовик:
```
git stash
```

Переехать в нужную ветку:
```
git сheckout имя_ветки
```

Выгрузить изменения:
```
git stash apply
```
-------------------------------------------

### А что делать, если сделали изменения не в той ветке и уже закоммитили?

Скопировать `hash` этого коммита. `hash` коммита можно не копировать, если это был последний коммит в этой ветке:
```
git log
```

Перейти в нужную ветку:
```
git checkout имя_ветки
```

Выгрузить коммит, тогда достаточно указать имя ветки (вместо `хеш_коммита`), откуда его забрали:
```
git checkout cherry-pick хеш_коммита 
```
-------------------------------------------

### Как объединить ветку master с другой веткой?

Переместиться в ветку `master`:
```
git checkout master
```

Объединить текущую ветку с указанной:
```
git merge имя_ветки -m "сообщение"
```

# Взаимодействие Git и GitHub через консоль

Для работы с **GitHub** нужно [зарегистрироваться](https://github.com) и привязать ssh-ключ.

-------------------------------------------

## Создание и привязка ssh-ключа

Переходим в каталог:
```
cd ~/.ssh
```
```
users/ваше_имя_пользователя/.ssh/
```

генерируем ключи
* вводим имя ключа
* вводим пароль (можно пропустить)
```
ssh-keygen -t rsa -b 4096 -C 'e-mail'
```

В профиле **GitHub**
* переходим в `Settings > SSH and GPG keys`
* нажимаем `New SSH Key`
* вводим имя ключа и вставляем содержимое файла `.ssh/key-name.pub`

В папке `.shh` создаем  файл `config` (без расширения) и вставляем:
```
Host github.com
	Identityfile ~/.ssh/key-name
```

Не перепутайте: `key-name.pub` - на **GitHub**, `key-name` (без `.pub`) - в `config`.

-------------------------------------------

## Основные команды для работы с GitHub

*origin - удалённый (облачный) репозиторий*

Привязать локальный репозиторий к удаленному и назвать его `origin`:
```
git remote add origin ssh-address
```

Показать связь с удаленными репозиториями:
```
git remote -v
```

Клонировать удаленный репозитрий:
```
git clone ssh-address
```

Отправить текущую локальную ветку в ветку `master` репозитория `origin`:
```
git push origin master
```

Получить изменения из ветки `master` репозитория `origin`:
```
git pull origin master
```
-------------------------------------------

### Примеры для прояснения разума

Находимся в ветке `какая_то_ветка`, хотим создать эту ветку в удаленном репозитории:
```
git push origin какая_то_ветка
```

отправить текущую локальную ветку в ветку `какая_то_ветка` 

-------------------------------------------

#### Не хочу каждый раз указывать путь, что делать?

Привязать текущую локальную ветку к удаленной `какая_то_ветка`:
* если нужно назвать удаленную ветку иначе, используйте `:` (например, `какая_то_ветка:branch-1`)
* теперь можно использовать `git push` в ветке `какая_то_ветка`
```
git push -u origin какая_то_ветка
```

Показать связь локальных и удаленных веток:
```
git branch -vv
```
-------------------------------------------
 
Находимся в ветке `master` и хотим получить ветку `branch-two`, у нас нет такой локальной ветки.

Получить изменения из удаленного репозитория `origin`:
```
git fetch origin
```

Гит создает нам локальную ветку, привязанную к удаленной:
```
git checkout branch-two
```
-------------------------------------------

### Работа со своим новым репозиторием

Случай, когда удаленный репозиторий только создан.

Здесь все просто, при создании репозитория (`Repositories > New`) **GitHub** сам подсказывает, что делать - 

Установить связь с удаленным репозиторием:
```
gite remote add origin ssh-address
```

Запушить коммиты в удаленный репозиторий
* в следующий раз из локальной ветки `master` можно использовать просто `git push`
```
git push -u origin master
```
-------------------------------------------

### Работа со своим, уже созданным, репозиторием

Случай, когда репозиторий был создан и уже ведется история.

Например, вы хотите работать со своим репозиторием с другого компьютера.

Скопировать ssh-адрес:
```
Clone or download > Clnoe with SSH
```

Клонировать удаленный репозиторий:
```
git clone ssh-address
```
-------------------------------------------

### Работа с форком

Случай, когда вы работаете с форком мастера-репозитория.

Автоматически форк не синхронизируется с мастер-репозиторием.  
Сделаем это самостоятельно:

1. Скопировать ssh-адрес мастер-репозитория (откуда был сделан форк):
```
Clone or download > Clnoe with SSH
```

2. Клонировать форк:
```
git clone ssh-address
```

3. Установить связь с мастер-репозиторием и назвать его `master-repos`:
```
git remote add master-repos ssh-address
```

4. Синхронизировать клон с веткой `master` мастер-репозитория:
```
git pull master-repos master
```

5. Отправить изменения в свой форк:
```
git push
```

Теперь для получения изменений из мастер-репозитория будем использовать последние два пункта.

-------------------------------------------

### У нас конфликт, вызывать полицию?

Конфликт возникает при неудачном автоматическом слиянии.

Допустим, мы добавили `background-color: #000`, делаем пуш, а **Git** нам говорит,  
что изменения уже до вас кто-то сделал, сначала заберите их.  
Мы забираем изменения и понимаем, что кто-то тоже добавил цвет фона, но другой.

```
CONFLICT (content): Merge conflict in main.css
Automatic merge failed; fix conflicts and then commit the result.
```
Что делать?

1. Открыть файл `main.css`
2. Решить конфликт самостоятельно

**END**
