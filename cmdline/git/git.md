# Основные команды для работы с Git через консоль

Для начала немного настроек (укажем имя и почту):

1. `git config --global user.name your-name`
2. `git config --global user.email your-email`

-------------------------------------------

* `git config --list`  - посмотреть сохранённые настройки
* `cat ~/.gitconfig` - выводит содержимое файла. Где `~/.gitconfig` - имя нужного файла

-------------------------------------------

* `git status` - показать состояние репозитория
* `git init` - создать репозиторий

-------------------------------------------

## Индексация изменений

* `git add имя_файла` - проиндексировать изменения файла
  * `git add .`  - проиндексировать все изменения

* `git diff имя_файла` - показать изменения непроиндексированного файла
  * добавим `--staged`, если файл уже был проиндексирован

-------------------------------------------

### Изменили файл, но изменения не понравились, как вернуть все обратно?

* `git checkout имя_файла` - отменить изменения до состояния текущего коммита

-------------------------------------------

### Что делать, если случайно проиндексировали лишний файл?

* `git reset HEAD имя_файла` - отменить индексацию файла

-------------------------------------------

## Коммиты

* `git commit -m "сообщение"` - собственно сам коммит

* `git log` - показать историю коммитов (здесь берем `hash`) до текущего (`q` - выйти из лога)
  * `--all` - все коммиты
  * `--oneline` - более удобный вывод (без автора и даты)
  * `--graph` - вывод схемой (удобно для веток)

* `git show хеш_коммита` - показать изменения в hash-коммите

-------------------------------------------

### Что делать, если случайно закоммитили лишний файл?

1. `git rm --cached style.css ` - удалить файл из последнего коммита
2. `git commit --amend --no-edit` - изменить коммит

-------------------------------------------

### А если допустили ошибку в commit-message?

* `git commit --amend -m "сообщение"` - изменить комментарий последнего коммита

-------------------------------------------

### Как вернуть состояние файла, как во-о-н в том коммите?

* `git checkout хеш_коммита имя_файла` - откатить состояние файла до hash-коммита
  * уберем `имя_файла`, если хотим откатить весь репозиторий

-------------------------------------------

## Ветки

* `git checkout -b имя_ветки` - создать ветку из текущего коммита
* `git branch` - показать список веток

-------------------------------------------

### Эта ветка больше не нужна, как быть?

* `git branch -d имя_ветки` - удалить ветку (нужно находиться в другой ветке)

-------------------------------------------

### Что делать, если ошиблись в названии ветки?

* `git branch -m name` - переименовать текущую ветку

-------------------------------------------

### Как создать ветку не из текущего коммита, а вон из того?

> Вчера начали изменения в дизайне, но вот появился еще один вариант,  
  создать коммит из текущего не получится, ведь здесь уже внесены изменения...

* `git checkout -b имя_ветки хеш_коммита` - создать ветку из коммита, где изменений еще не было

-------------------------------------------

### Что делать, если сделали изменения не в той ветке, но еще не закоммитили?

1. `git stash` - загрузить изменения в стек-грузовик
2. `git сheckout имя_ветки` - переехать в нужную ветку
3. `git stash apply` - выгрузить изменения

-------------------------------------------

### А что делать, если сделали изменения не в той ветке и уже закоммитили?

1. `git log` - скопировать hash этого коммита
    * hash коммита можно не копировать, если это был последний коммит в этой ветке

2. `git checkout имя_ветки` - перейти в нужную ветку

2. `git checkout cherry-pick хеш_коммита` - выгрузить коммит
    * и тогда достаточно указать имя ветки (вместо `хеш_коммита`), откуда его забрали

-------------------------------------------

### Как объединить ветку master с другой веткой?

1. `git checkout master` - переместиться в ветку `master`
2. `git merge имя_ветки -m "сообщение"` - объединить текущую ветку с указанной


# Взаимодействие Git и GitHub через консоль

Для работы с **GitHub** нужно [зарегистрироваться](https://github.com) и привязать ssh-ключ.

-------------------------------------------

## Создание и привязка ssh-ключа

1. `cd ~/.ssh` - переходим в каталог `users/your-user-name/.ssh/`

2. `ssh-keygen -t rsa -b 4096 -C 'e-mail'` - генерируем ключи
    * вводим имя ключа
    * вводим пароль (можно пропустить)

3. В профиле **GitHub**:
     * переходим в `Settings > SSH and GPG keys`
     * нажимаем `New SSH Key`
     * вводим имя ключа и вставляем содержимое файла `.ssh/key-name.pub`

4. В папке `.shh` создаем  файл `config` (без расширения) и вставляем:

```
Host github.com
	Identityfile ~/.ssh/key-name
```

Не перепутайте: `key-name.pub` - на **GitHub**, `key-name` (без `.pub`) - в `config`.

-------------------------------------------

## Основные команды для работы с GitHub

> origin - удалённый (облачный) репозиторий

* `git remote add origin ssh-address` - привязать локальный репозиторий к удаленному и назвать его `origin`
* `git remote -v` - показать связь с удаленными репозиториями

* `git clone ssh-address` - клонировать удаленный репозитрий

* `git push origin master` - отправить текущую локальную ветку в ветку `master` репозитория `origin`
* `git pull origin master` - получить изменения из ветки `master` репозитория `origin`

-------------------------------------------

### Примеры для прояснения разума

1. Находимся в ветке `какая_то_ветка`, хотим создать эту ветку в удаленном репозитории.

    * `git push origin какая_то_ветка` - отправить текущую локальную ветку в ветку `какая_то_ветка` 

-------------------------------------------

#### Не хочу каждый раз указывать путь, что делать?

* `git push -u origin какая_то_ветка` - привязать текущую локальную ветку к удаленной `какая_то_ветка`
    * если нужно назвать удаленную ветку иначе, используйте `:` (например, `какая_то_ветка:branch-1`)
    * теперь можно использовать `git push` в ветке `какая_то_ветка`

* `git branch -vv` - показать связь локальных и удаленных веток

-------------------------------------------
 
2. Находимся в ветке `master` и хотим получить ветку `branch-two`, у нас нет такой локальной ветки.
    * `git fetch origin` - получить изменения из удаленного репозитория `origin`
    * `git checkout branch-two` - гит создает нам локальную ветку, привязанную к удаленной

-------------------------------------------

### Работа со своим новым репозиторием

Случай, когда удаленный репозиторий только создан.

Здесь все просто, при создании репозитория (`Repositories > New`) **GitHub** сам подсказывает, что делать:

1. `gite remote add origin ssh-address` - установить связь с удаленным репозиторием
2. `git push -u origin master` - запушить коммиты в удаленный репозиторий
    * в следующий раз из локальной ветки `master` можно использовать просто `git push`

-------------------------------------------

### Работа со своим, уже созданным, репозиторием

Случай, когда репозиторий был создан и уже ведется история.

Например, вы хотите работать со своим репозиторием с другого компьютера.

1. `Clone or download > Clnoe with SSH` - скопировать ssh-адрес
2. `git clone ssh-address` - клонировать удаленный репозиторий

-------------------------------------------

### Работа с форком

Случай, когда вы работаете с форком мастера-репозитория.

Автоматически форк не синхронизируется с мастер-репозиторием.  
Сделаем это самостоятельно:

1. `Clone or download > Clnoe with SSH` - скопировать ssh-адрес мастер-репозитория (откуда был сделан форк)
2. `git clone ssh-address` - клонировать форк
3. `git remote add master-repos ssh-address` - установить связь с мастер-репозиторием и назвать его `master-repos`
4. `git pull master-repos master` - синхронизировать клон с веткой `master` мастер-репозитория
5. `git push` - отправить изменения в свой форк

Теперь для получения изменений из мастер-репозитория будем использовать последние два пункта.

-------------------------------------------

### У нас конфликт, вызывать полицию?

Конфликт возникает при неудачном автоматическом слиянии.

Допустим, мы добавили `background-color: #000`, делаем пуш, а **Git** нам говорит,  
что изменения уже до вас кто-то сделал, сначала заберите их.  
Мы забираем изменения и понимаем, что кто-то тоже добавил цвет фона, но другой.

```
CONFLICT (content): Merge conflict in main.css
Automatic merge failed; fix conflicts and then commit the result.
```
Что делать?

1. Открыть файл `main.css`
2. Решить конфликт самостоятельно
